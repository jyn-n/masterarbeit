\section{Turing machines} \label{turing_machines}

\input{section__turing_machines/subs_1__turing_machine_definition}

\input{section__turing_machines/subs_2__basic_notions}

\input{section__turing_machines/subs_3__lemma_foolproof_concatenation}

\input{section__turing_machines/subs_4__lemma_foolproofness}

\input{section__turing_machines/subs_5__main_theorem}

%\begin{Definition}
%	If $\mathcal{M}$ and $\mathcal{N}$ are classes of Turing machines, $\mathcal{N}$ has \emph{no lesser computability} than $\mathcal{M}$ (write $\mathcal{M} \leq \mathcal{N}$),
%	if for every $M \in \mathcal{M}$ there is an $N \in \mathcal{N}$ and a computable map $F: IC(M) \to C(N)$ such that \IM{F(AC(M) = AC(N)}.
%\end{Definition}

%Thm same computability

%\begin{Theorem}\label{thm_computability}
%	The following classes have the same computability:
%
%	\begin{enumerate}
%		\item{Turing machines on 1 tape}
%			\label{thm_computability:tm1}
%		\item{readonly Turing machines on 2 tapes}
%			\label{thm_computability:r2}
%		\item{readonly Turing machines on any number of tapes}
%			\label{thm_computability:r}
%		\item{foolproof readonly Turing machines on 2 tapes}
%			\label{thm_computability:fr2}
%	\end{enumerate}
%\end{Theorem}
%
%Later we will only actually need
%\mbox{\ref{thm_computability:tm1} $\rightsquigarrow$ \ref{thm_computability:fr2}}
%but \ref{thm_computability:r2} is a useful step in the proof,
%\ref{thm_computability:r} we basically get for free
%and \mbox{\ref{thm_computability:fr2} $\rightsquigarrow$ \ref{thm_computability:tm1}} 
%shall be proven for sake of completeness.
%
%\proof
%\mbox{\ref{thm_computability:r2} $\rightsquigarrow$ \ref{thm_computability:r}} is clear ($N = M$ and $F = id$).
%We will prove
%\mbox{\ref{thm_computability:tm1} $\rightsquigarrow$ \ref{thm_computability:r2}},
%\mbox{\ref{thm_computability:r} $\rightsquigarrow$ \ref{thm_computability:fr2}} and
%\mbox{\ref{thm_computability:fr2} $\rightsquigarrow$ \ref{thm_computability:tm1}}
%each by first providing the map $F$ which should preserve acceptance and then the Turing machine $N$, making sure $N$ rejects every \IM{c \in IC(N) \setminus F(IC(M))}.
%
%\subsubsection*{\ref{thm_computability:tm1} $\rightsquigarrow$ \ref{thm_computability:r2}}
%
%Let $M$ be a Turing machine on 1 tape. Consider a tape over the alphabet \IM{A(M) \cup S(M)}. This tape may contain a finite configuration $(a_{-l},\cdots,a_k,s) \in FC(M)$ by putting $s$ leftmost, followed by the $a_i$ and marking $a_0$ and no other symbol. The marking is important so we can tell the position of the $a_i$ on the tape.
%If we add to the alphabet some separator symbol $|$ a tape can contain a whole sequence of configurations. We shall now try to create a readonly Turing machine on 2 tapes $N$ that checks if such a sequence is of the form 
%\begin{align*}
%	(c_0, T(c_0), T^2(c_0), ... T^m(c_0))
%\end{align*}
%where \IM{T^m(c_0) = T^{m+1}(c_0)} and \IM{T = T^M}.
%
%In order to do this we should first check that both tapes contain the same input. At the same time we can check whether the input is of the form
%\begin{align*}
%	|c|c^\prime|c^{\prime\prime}|\cdots
%\end{align*}
%for some finite configurations \IM{c,c^\prime,c^{\prime\prime}} etc
%and reject if any of these conditions are not met.
%
%Checking if some word bounded by separators actually describes a configuration can be done by checking if the first symbol is in $S$, every other symbol is in $A$ and when encountering a marking memorizing the fact and rejecting if another marking is met.
%
%Afterwards we move both tapes to their original positions and advance the second tape by one configuration.
%
%Now we only need to check that if the first tape is at some configuration $\tilde{c}$, the second tape is at the start of $T^M(\tilde{c})$, advancing both tapes by one configuration in the process and repeat until either this is not true, in which case we reject, or we reach the end of the second tape, in which case we accept if an only if the configurations we considered last are identical and have state $ACCEPT$.
%
%To achieve this let $(a,s)$ and $(b,t)$ be the configurations on the first and second tape respectively. We first read the states $s$ and $t$ and memorize them.
%Then we have both tapes skip any initial unmarked $EMPTY$ symbols, as those may or may not be specified explicitly without affecting equality of configurations.
%Then both tapes are advanced one step at a time until we find a marking on either tape. Up to this point both tapes should be equal or we reject.
%Now things depend on whether the marking was found on the first or second tape or both.
%In case there was a marking on the first tape and this tape contains symbol $a$ at position $0$, the second tape should contain the symbol \IM{T^M_A(a,s)} and be marked if and only if \IM{T^M_D(a,s) = 0}. Furthermore we should have that \IM{T_S(a,s) = t}. All of these conditions can easily be checked as all the relevant information is either in memory or on the observable parts of the tapes.
%If any of these conditions is not met we again reject.
%If \IM{T^M_D(a,s) = -1} we should already have encountered a marking on the second tape. But we have not, therefore we reject.
%
%If there was a marking on the first tape and \IM{T^M_D(a,s) = 1}, or there was no marking on the first tape but on the second one, the next position of the respective other tape should be marked, a fact we memorize. Then advance both tapes one step and check if the markings are correct according to what we memorized. If now there is a marking on the first tape perform the above check concerning the symbol on the second tape.
%
%Then we continue advancing both tapes expecting no differences barring some $EMPTY$ symbols at the end.
%This way we reach the $|$ marking the end of the configuration on both tapes if and only if \IM{T^M(a,s) = (b,t)}
%
%During this whole process if we ever encounter a difference in the configurations (ignoring any unmarked $EMPTY$ at the starts and ends) we should remember the fact so that we can decide whether or not to accept if this configuration happened to be the last one on the second tape.
%
%\subsubsection*{\ref{thm_computability:r} $\rightsquigarrow$ \ref{thm_computability:fr2}}
%
%Let $M$ be a read only Turing machine. We first restrict to the case that $M$ is on just one single tape.
%The idea here is as follows: If we somehow knew that \IM{T_D(\_,s) = 1} for every \IM{s \in S \setminus \{ACCEPT,REJECT\}} foolproofness would easily follow since unless the machine has already stopped, the tape is advanced by 1 every step and a readonly Turing machine may do so only as long as it does not hit any $EMPTY$ symbol because of our further requirement on such machines.
%For any finite configuration this will happen after finitely many steps and thus the Turing machine would stop.
%
%To construct such a Turing machine we consider the ``reading word'' $r$ of any input. This word consists of the entries on the tape as they are consecutively read by $M$: If $M$ stops for an initial configuration $c$ after $K \in \N$ steps, we set
%\begin{align*}
%	r^M(c)_i := (T^M_A)^i(c)~\forall k \in \{0,...,k\}
%\end{align*}
%Now we can easily construct a foolproof Turing machine $N$ that simulates the behaviour of $M$ when applied to the reading word of any input to $M$ by setting
%\begin{align*}
%	T^N_D(\_,s) := \begin{cases}0&\text{, if}~s \in \{ACCEPT,REJECT\} \\1&\text{, otherwise}\end{cases}
%\end{align*}
%and
%\begin{align*}
%	T^N_S := T^M_S
%\end{align*}
%Now we only need to make sure that a given input actually is a reading word. Here we require our second tape. The input to the second tape should be the original input to $M$. Let that input be called $c$. Then the input to the first tape should be the reading word $r^M(c)$, with each position $i$ on the tape marked by $(T^M_D)^{i+1}(c)$.
%
%We divide $N$ into three phases: The first phase checks whether the input to the first tape is actually the reading word of the input to the second tape when following directions as indicated by the markings, which should correspond to the movement of the tape in $M$.
%That is if $a$ and $b$ denote the tapes, $m \in \{-1,0,1\}^\Z$ denotes the markings on the first tape and $s \in S$ we have
%\begin{align*}
%	T^N_S(((a,m),b),s) = \begin{cases}T^M_S(b,s)&\text{, if}~a_0 = b_0~\text{and}~m_0 = T^M_D(b,s)\\REJECT&\text{, otherwise}\end{cases}
%\end{align*}
%and further in case we did not reject
%\begin{align*}
%	T^N_D(((a,m),b),s) = \begin{pmatrix}1\\m_0\end{pmatrix}
%\end{align*}
%The second phase resets the tapes to their initial positions, that is moves each of them left until they hit an $EMPTY$ symbol after which the tapes are moved right by one step.
%
%Finally the third phase simulates $M$.
%
%This is still foolproof, as each of the three phases, when regarded as a single Turing machine is foolproof and the concatenation of foolproof Turing machines is clearly foolproof again since when one Turing machine eventually stops after finitely many steps, the second machine is started with some configuration, which again stops after finitely many steps and so on.
%
%For the case where $M$ has multiple tapes we first realize that we can combine mutliple tapes into one by replacing the alphabet $A$ by $A^n$. Doing so loses us the ability to move the tapes independently. But this is not much of a problem since still the second tape may contain the combined inputs to $M$ and the first tape holds their combined reading words, each with appropriate directions.
%We check, one after another, if the reading words are correct and then simulate $M$. This is possible since for the simulation we only need to consider the first tape, which contains the consecutive symbols on all the tapes as observed by $M$.
