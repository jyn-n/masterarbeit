\subsection{Computability}
\label{halting_problem:computability}

Similar to the notion of decidability as presented in Definition \ref{halting_problem:decidability:definition_decidable} we can define computability:

\begin{Definition}
	Let $X$ and $Y$ be countable sets, $A$ an alphabet and let \emb{\cdot} be embeddings from $X$ or $Y$ to $A^*$.

	Further let $f:X \to Y$ be a map.
	Then $f$ is called \emph{computable} if there is a Turing machine on the alphabet $A$ with Transition map $T$ such that
	\begin{align*}
		T^\infty(\emb{x},\INI) = (\emb{f(x)},\ACC) ~\text{for every}~ x \in X
	\end{align*}
\end{Definition}

\begin{Remark}
	If $Y$ has more that countably many elements and embeds to $A^\Z$, then we define the map $f$ to be computable if there is a sequence of Turing machines with transition maps $T_i$ such that for every $x \in X$ there are $a_i \in A^*$ such that
	\begin{align*}
		T_i^*(\emb{x}, \INI) = (a_i,\ACC) ~\text{for every}~ i \in \N
	\end{align*}
	and $a_i \xrightarrow{i \to \infty} \emb{f(x)}$.

	Equivalently we could say that there is a single Turing machine such that the tape-part of $T^i(\emb{x},\INI)$ up to translation of the tape converges to $\emb{f(x)}$.
\end{Remark}

In the following chapters we prove some problems to be undecidable.
This means that there is a way of embedding instances of that problem into the words over some alphabet and no matter which embedding we choose there is no Turing machine that accepts instances of the problem with positive answer and rejects instances with negative answer.
To do so, we will manipulate a multitude of mathematical objects and usually do so in a computable way, making sure that in the end there will be a Turing machine which translates instances of our original problem to instances of the halting problem.
Then we can claim that if there was a Turing machine that solves our problem, then there would also be a Turing machine which solves the halting problem, leading to a contradiction.

But rigorously checking computability in every instance would probably overshadow everything else done in this work.
Therefore we resolve to a more intuitive notion of computability.
A nice description of this notion can be found in \cite{bbj07}:
\begin{quotation}
	``A function $f$ from positive integers to positive integers is called \emph{effectively computable} if a list of instructions can be given that in principle make it possible to determine the value $f(n)$ for any argument $n$. The instructions must be completely definite and explicit. They should tell you at each step what to do, not tell you to go ask someone else what to do, or figure out for yourself what to do: the instructions should require no external sources of information, and should require no ingenuity to execute, so that one might hope to automate the process of applying the rules, and have it performed by some mechanical device.''
\end{quotation}
This basically boils down to the slogan
\begin{quotation}
	\textbf{``Constructive proofs yield computable results''}
\end{quotation}
Of course we have to be extra careful when employing such a notion and while reading this work we should always convince ourselves that all results are actually computable whenever necessary.
